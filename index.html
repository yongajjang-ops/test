<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>동옥의 AI TETRIS</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@700&display=swap" rel="stylesheet">
    <style>
        * { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body { overscroll-behavior: none; position: fixed; width: 100%; height: 100%; }
        @keyframes camelWalk {
            from { transform: translateX(100vw); }
            to { transform: translateX(-120%); }
        }
        .animate-camel-walk { animation: camelWalk 40s linear infinite; }
        .game-title { font-family: 'Gaegu', cursive; font-weight: 700; }
        @keyframes blockFall {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(30px); opacity: 0; }
        }
        .block-fall { animation: blockFall 0.6s ease-out forwards; }
        .camel-scare { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 22;
        
        const SPEED_TABLE = [1000, 850, 700, 550, 400, 300, 220, 160, 120, 90, 70]; // 레벨별 ms

        const TETROMINOS = {
            I: { shape: [[1,1,1,1]], color: 'bg-cyan-500 shadow-lg' },
            O: { shape: [[1,1],[1,1]], color: 'bg-yellow-500 shadow-lg' },
            T: { shape: [[0,1,0],[1,1,1]], color: 'bg-purple-500 shadow-lg' },
            S: { shape: [[0,1,1],[1,1,0]], color: 'bg-green-500 shadow-lg' },
            Z: { shape: [[1,1,0],[0,1,1]], color: 'bg-red-500 shadow-lg' },
            J: { shape: [[1,0,0],[1,1,1]], color: 'bg-blue-500 shadow-lg' },
            L: { shape: [[0,0,1],[1,1,1]], color: 'bg-orange-500 shadow-lg' }
        };

        const createEmptyBoard = () => Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));

        const Tetris = () => {
            const [board, setBoard] = useState(createEmptyBoard());
            const [currentPiece, setCurrentPiece] = useState(null);
            const [nextPiece, setNextPiece] = useState(null);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [gameOver, setGameOver] = useState(false);
            const [score, setScore] = useState(0);
            const [level, setLevel] = useState(1);
            const [lines, setLines] = useState(0);
            const [isPaused, setIsPaused] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const [gameOverAnimation, setGameOverAnimation] = useState(false);
            const [scareCamels, setScareCamels] = useState(false);

            const currentHour = new Date().getHours();
            const isDaytime = currentHour >= 6 && currentHour < 18;

            const getRandomPiece = () => {
                const keys = Object.keys(TETROMINOS);
                const type = keys[Math.floor(Math.random() * keys.length)];
                return { ...TETROMINOS[type], type };
            };

            const checkCollision = useCallback((piece, pos, currentBoard) => {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newX = pos.x + x;
                            const newY = pos.y + y;
                            if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
                            if (newY >= 0 && currentBoard[newY][newX]) return true;
                        }
                    }
                }
                return false;
            }, []);

            const rotateMatrix = (matrix) => matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());

            const tryWallKick = (piece, pos, currentBoard) => {
                const kicks = [
                    { x: 0, y: 0 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: -2, y: 0 }, { x: 2, y: 0 }
                ];

                for (const kick of kicks) {
                    const newPos = { x: pos.x + kick.x, y: pos.y + kick.y };
                    if (!checkCollision(piece, newPos, currentBoard)) {
                        return newPos;
                    }
                }
                return null;
            };

            const mergePiece = useCallback(() => {
                const newBoard = board.map(row => [...row]);
                currentPiece.shape.forEach((row, dy) => {
                    row.forEach((val, dx) => {
                        if (val) {
                            const y = position.y + dy;
                            const x = position.x + dx;
                            if (y >= 0 && y < BOARD_HEIGHT) {
                                newBoard[y][x] = currentPiece.color;
                            }
                        }
                    });
                });
                return newBoard;
            }, [board, currentPiece, position]);

            const clearLines = useCallback((currentBoard) => {
                let cleared = 0;
                const newBoard = currentBoard.filter(row => {
                    if (row.every(cell => cell !== null)) {
                        cleared++;
                        return false;
                    }
                    return true;
                });

                while (newBoard.length < BOARD_HEIGHT) {
                    newBoard.unshift(Array(BOARD_WIDTH).fill(null));
                }

                return { newBoard, cleared };
            }, []);

            const spawnNewPiece = useCallback(() => {
                const piece = nextPiece || getRandomPiece();
                let startX = Math.floor((BOARD_WIDTH - piece.shape[0].length) / 2);
                if (piece.type === 'I') startX = Math.floor(BOARD_WIDTH / 2) - 2; // I는 좀 더 중앙
                if (piece.type === 'O') startX = Math.floor(BOARD_WIDTH / 2) - 1;

                const spawnPos = { x: startX, y: 0 };

                if (checkCollision(piece, spawnPos, board)) {
                    setGameOver(true);
                    setGameOverAnimation(true);
                    setScareCamels(true);
                    setTimeout(() => setScareCamels(false), 2000);
                    return;
                }

                setCurrentPiece(piece);
                setNextPiece(getRandomPiece());
                setPosition(spawnPos);
            }, [board, nextPiece]);

            const moveDown = useCallback(() => {
                if (!currentPiece || gameOver || isPaused) return;
                const newPos = { ...position, y: position.y + 1 };

                if (checkCollision(currentPiece, newPos, board)) {
                    const merged = mergePiece();
                    const { newBoard, cleared } = clearLines(merged);

                    // 점수 계산 (고전 스타일)
                    const lineScores = [0, 40, 100, 300, 1200];
                    const points = lineScores[cleared] * level;
                    setScore(prev => prev + points);

                    const newLines = lines + cleared;
                    setLines(newLines);

                    // 레벨업 (10줄마다)
                    const newLevel = Math.floor(newLines / 10) + 1;
                    if (newLevel > level) {
                        setLevel(newLevel);
                    }

                    setBoard(newBoard);
                    spawnNewPiece();
                } else {
                    setPosition(newPos);
                }
            }, [currentPiece, position, board, gameOver, isPaused, level, lines, mergePiece, clearLines, spawnNewPiece]);

            const moveHorizontal = useCallback((dir) => {
                if (!currentPiece || gameOver || isPaused) return;
                const newPos = { ...position, x: position.x + dir };
                if (!checkCollision(currentPiece, newPos, board)) {
                    setPosition(newPos);
                }
            }, [currentPiece, position, board, gameOver, isPaused]);

            const rotate = useCallback(() => {
                if (!currentPiece || gameOver || isPaused || currentPiece.type === 'O') return;

                const rotatedShape = rotateMatrix(currentPiece.shape);
                const rotatedPiece = { ...currentPiece, shape: rotatedShape };

                const kickedPos = tryWallKick(rotatedPiece, position, board);
                if (kickedPos) {
                    setCurrentPiece(rotatedPiece);
                    setPosition(kickedPos);
                }
            }, [currentPiece, position, board, gameOver, isPaused]);

            const hardDrop = useCallback(() => {
                if (!currentPiece || gameOver || isPaused) return;
                let newPos = { ...position };
                while (!checkCollision(currentPiece, { ...newPos, y: newPos.y + 1 }, board)) {
                    newPos.y++;
                }
                setPosition(newPos);
                moveDown(); // 바로 착지 처리
            }, [currentPiece, position, board, moveDown, gameOver, isPaused]);

            useEffect(() => {
                if (!gameStarted || gameOver || isPaused) return;
                const interval = setInterval(moveDown, SPEED_TABLE[Math.min(level - 1, SPEED_TABLE.length - 1)]);
                return () => clearInterval(interval);
            }, [moveDown, gameStarted, gameOver, isPaused, level]);

            const startGame = () => {
                setBoard(createEmptyBoard());
                setScore(0);
                setLines(0);
                setLevel(1);
                setGameOver(false);
                setGameOverAnimation(false);
                setScareCamels(false);
                setIsPaused(false);
                setGameStarted(true);
                spawnNewPiece();
            };

            const bgGradient = isDaytime 
                ? 'from-yellow-300 via-orange-200 to-yellow-400'
                : 'from-indigo-900 via-purple-900 to-blue-900';

            const sandColor = isDaytime ? 'from-yellow-600 to-yellow-400' : 'from-gray-700 to-gray-600';

            return (
                <div className={`relative flex flex-col items-center min-h-screen bg-gradient-to-b ${bgGradient} text-white overflow-hidden`}>
                    {/* 태양/달 */}
                    {isDaytime ? (
                        <div className="absolute top-6 right-8 w-20 h-20 bg-yellow-300 rounded-full shadow-2xl opacity-90"></div>
                    ) : (
                        <div className="absolute top-6 right-8 w-20 h-20 bg-gray-200 rounded-full shadow-2xl opacity-80">
                            <div className="absolute top-2 right-2 w-16 h-16 bg-indigo-950 rounded-full"></div>
                        </div>
                    )}

                    {/* 사막 바닥 */}
                    <div className={`absolute bottom-0 left-0 right-0 h-48 bg-gradient-to-t ${sandColor} rounded-t-full`}></div>

                    {/* 낙타들 */}
                    <div className="absolute bottom-10 left-0 right-0 h-20 overflow-hidden z-10">
                        <div className={`animate-camel-walk flex gap-40 ${scareCamels ? 'camel-scare' : ''}`}>
                            {[...Array(4)].map((_, i) => (
                                <div key={i} className="flex flex-col items-center min-w-max scale-90">
                                    <div className="relative w-24 h-16">
                                        <div className="w-24 h-10 bg-amber-800 rounded-full"></div>
                                        <div className="absolute top-0 left-1/4 -translate-x-1/2 -translate-y-3 w-10 h-10 bg-amber-900 rounded-full"></div>
                                        <div className="absolute top-0 right-1/4 translate-x-1/2 -translate-y-3 w-10 h-10 bg-amber-900 rounded-full"></div>
                                        <div className="absolute -top-4 left-0 w-6 h-14 bg-amber-800 rounded"></div>
                                        <div className="absolute -top-8 left-1 w-8 h-8 bg-amber-800 rounded-full"></div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="relative z-20 w-full max-w-sm flex flex-col items-center pt-4 px-4">
                        <h1 className="game-title text-4xl font-bold mb-3 text-amber-900 drop-shadow-lg">
                            동옥의 AI TETRIS
                        </h1>

                        {gameStarted && (
                            <div className="mb-4 flex gap-6 text-lg font-bold text-amber-900 drop-shadow">
                                <div>점수: {score.toLocaleString()}</div>
                                <div>레벨: {level}</div>
                                <div>줄: {lines}</div>
                            </div>
                        )}

                        {!gameStarted ? (
                            <button
                                onClick={startGame}
                                className="mt-8 px-10 py-4 bg-blue-600 hover:bg-blue-700 active:bg-blue-800 rounded-xl text-2xl font-bold shadow-lg"
                            >
                                게임 시작!
                            </button>
                        ) : (
                            <>
                                <div className="relative mb-6">
                                    <div
                                        className="border-4 border-gray-800 bg-gray-900 rounded-xl overflow-hidden shadow-2xl"
                                        style={{
                                            display: 'grid',
                                            gridTemplateColumns: `repeat(${BOARD_WIDTH}, ${CELL_SIZE}px)`,
                                            gap: '3px',
                                            padding: '4px'
                                        }}
                                    >
                                        {board.map((row, y) => row.map((cell, x) => {
                                            const isGhost = currentPiece && 
                                                y >= position.y && y < position.y + currentPiece.shape.length &&
                                                x >= position.x && x < position.x + currentPiece.shape[0]?.length &&
                                                currentPiece.shape[y - position.y]?.[x - position.x];
                                            
                                            return (
                                                <div
                                                    key={`${y}-${x}`}
                                                    className={`
                                                        ${cell || 'bg-gray-800/60'} 
                                                        ${isGhost ? 'bg-white/20' : ''}
                                                        ${gameOverAnimation ? 'block-fall' : ''}
                                                        rounded-md
                                                    `}
                                                    style={{ width: CELL_SIZE, height: CELL_SIZE }}
                                                />
                                            );
                                        }))}
                                    </div>

                                    {gameOver && (
                                        <div className="absolute inset-0 flex items-center justify-center bg-black/70">
                                            <div className="text-5xl font-bold text-red-600 animate-pulse">
                                                GAME OVER
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* 다음 피스 & 정보 */}
                                <div className="flex justify-between w-full max-w-xs mb-6">
                                    <div className="bg-gray-800/80 p-3 rounded-lg">
                                        <div className="text-sm text-yellow-300 mb-1">NEXT</div>
                                        {nextPiece && (
                                            <div style={{
                                                display: 'grid',
                                                gridTemplateColumns: 'repeat(4, 20px)',
                                                gap: '2px'
                                            }}>
                                                {Array(4).fill().map((_, y) => 
                                                    Array(4).fill().map((_, x) => {
                                                        const py = y - Math.floor((4 - nextPiece.shape.length)/2);
                                                        const px = x - Math.floor((4 - nextPiece.shape[0]?.length||0)/2);
                                                        const active = py >= 0 && py < nextPiece.shape.length &&
                                                                      px >= 0 && px < nextPiece.shape[0]?.length &&
                                                                      nextPiece.shape[py]?.[px];
                                                        return (
                                                            <div
                                                                key={`${y}-${x}`}
                                                                className={`${active ? nextPiece.color : 'bg-gray-900/70'} rounded-sm`}
                                                                style={{ width: 20, height: 20 }}
                                                            />
                                                        );
                                                    })
                                                )}
                                            </div>
                                        )}
                                    </div>

                                    <div className="bg-gray-800/80 p-3 rounded-lg text-center">
                                        <div className="text-sm text-yellow-300 mb-1">SPEED</div>
                                        <div className="text-2xl font-bold">Lv.{level}</div>
                                    </div>
                                </div>

                                {/* 컨트롤 */}
                                {!gameOver && (
                                    <div className="grid grid-cols-3 gap-4 w-full max-w-xs">
                                        <button onTouchStart={(e)=>{e.preventDefault(); moveHorizontal(-1);}} className="bg-gray-700 active:bg-gray-600 py-6 text-3xl rounded-xl">←</button>
                                        <button onTouchStart={(e)=>{e.preventDefault(); rotate();}} className="bg-blue-600 active:bg-blue-500 py-6 text-3xl rounded-xl">↻</button>
                                        <button onTouchStart={(e)=>{e.preventDefault(); moveHorizontal(1);}} className="bg-gray-700 active:bg-gray-600 py-6 text-3xl rounded-xl">→</button>
                                        <button onTouchStart={(e)=>{e.preventDefault(); setIsPaused(p=>!p);}} className="bg-yellow-600 active:bg-yellow-500 py-6 text-3xl rounded-xl col-span-1">||</button>
                                        <button onTouchStart={(e)=>{e.preventDefault(); hardDrop();}} className="bg-red-600 active:bg-red-500 py-6 text-xl rounded-xl col-span-2">DROP</button>
                                    </div>
                                )}

                                {gameOver && (
                                    <div className="mt-6 flex gap-4">
                                        <button onClick={startGame} className="px-8 py-4 bg-green-600 rounded-xl text-xl font-bold">다시 도전!</button>
                                    </div>
                                )}
                            </>
                        )}
                    </div>

                    <div className="absolute bottom-3 right-3 text-xs text-amber-900 bg-yellow-100/60 px-3 py-1 rounded">
                        이동옥 • 2026.01
                    </div>
                </div>
            );
        };

        ReactDOM.render(<Tetris />, document.getElementById('root'));
    </script>
</body>
</html>